/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./nashornPolyfills.es6");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./nashornPolyfills.es6":
/*!******************************!*\
  !*** ./nashornPolyfills.es6 ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\n\n// COMPILE AND RUN IN NASHORN\n\n// Basic polyfilling (exports, global, window, process, console)\n// must be run hardcoded from inside the engine, for some reason:\n/*\nif (typeof exports == 'undefined') { var exports = {}; }\nif (typeof global === 'undefined') { var global = this; }\nif (typeof window === 'undefined') { var window = this; }\nif (typeof process === 'undefined') { var process = {env:{}}; }\nif (typeof console === 'undefined') { var console = {}; }\nconsole.debug = print;\nconsole.log = print;\nconsole.warn = print;\nconsole.error = print;\n*/\n\nvar context = typeof window !== 'undefined' ? window : global;\n\n// Polyfills Set and Map:\nvar Map = __webpack_require__(/*! es6-set-and-map */ \"./node_modules/es6-set-and-map/src/main.js\").map;\nvar Set = __webpack_require__(/*! es6-set-and-map */ \"./node_modules/es6-set-and-map/src/main.js\").set;\n(function (window) {\n    if (typeof window.Map === 'undefined') window.Map = Map;\n    if (typeof window.Set === 'undefined') window.Set = Set;\n})(context);\n\n// polyfills setTimeout() and related\n// Based on:\n// https://gist.github.com/josmardias/20493bd205e24e31c0a406472330515a\n//\n// NOTE:\n// \"At least one timeout needs to be set, larger then your code bootstrap or Nashorn will run forever. \n// Preferably, put a timeout 0 after your code bootstrap.\"\n(function (context) {\n    'use strict';\n\n    var Timer = Java.type('java.util.Timer');\n    var Phaser = Java.type('java.util.concurrent.Phaser');\n\n    var timer = new Timer('jsEventLoop', false);\n    var phaser = new Phaser();\n\n    var timeoutStack = 0;\n    function pushTimeout() {\n        timeoutStack++;\n    }\n    function popTimeout() {\n        timeoutStack--;\n        if (timeoutStack > 0) {\n            return;\n        }\n        timer.cancel();\n        phaser.forceTermination();\n    }\n\n    var onTaskFinished = function onTaskFinished() {\n        phaser.arriveAndDeregister();\n    };\n\n    if (typeof context.setTimeout === 'undefined') {\n        context.setTimeout = function (fn, millis /* [, args...] */) {\n            var args = [].slice.call(arguments, 2, arguments.length);\n\n            var phase = phaser.register();\n            var canceled = false;\n            timer.schedule(function () {\n                if (canceled) {\n                    return;\n                }\n\n                try {\n                    fn.apply(context, args);\n                } catch (e) {\n                    print(e);\n                } finally {\n                    onTaskFinished();\n                    popTimeout();\n                }\n            }, millis);\n\n            pushTimeout();\n\n            return function () {\n                onTaskFinished();\n                canceled = true;\n                popTimeout();\n            };\n        };\n    }\n\n    if (typeof context.clearTimeout === 'undefined') {\n        context.clearTimeout = function (cancel) {\n            cancel();\n        };\n    }\n\n    if (typeof context.setInterval === 'undefined') {\n        context.setInterval = function (fn, delay /* [, args...] */) {\n            var args = [].slice.call(arguments, 2, arguments.length);\n\n            var cancel = null;\n\n            var loop = function loop() {\n                cancel = context.setTimeout(loop, delay);\n                fn.apply(context, args);\n            };\n\n            cancel = context.setTimeout(loop, delay);\n            return function () {\n                cancel();\n            };\n        };\n    }\n\n    if (typeof context.clearInterval === 'undefined') {\n        context.clearInterval = function (cancel) {\n            cancel();\n        };\n    }\n})(context);\n\ncontext.setTimeout(function () {}, 1);\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./nashornPolyfills.es6?");

/***/ }),

/***/ "./node_modules/es6-set-and-map/src/main.js":
/*!**************************************************!*\
  !*** ./node_modules/es6-set-and-map/src/main.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("( function ( root, factory ) {\n\tif( true ) {\n\t\tmodule.exports = factory();\n\t} else {}\n} ) ( this, function () {\n\t'use strict';\n\n\tvar self = {}, \n\t\tmain = self, \n\t\tsymbols_supported = typeof Symbol !== 'undefined';\n\n\tvar ArrayProto = Array.prototype;\n\tvar HasOwn = ( function () {\n\t\tvar has_own = {}.hasOwnProperty;\n\t\treturn function HasOwn( target, name ) {\n\t\t\treturn !!name && has_own.call( target, name );\n\t\t};\n\t} ) ();\n\tvar IsArray = Array.isArray;\n\tfunction IsObject( value ) { return value != null && ( typeof value === 'function' || typeof value === 'object' ); };\n\tfunction IsScalar( value ) { return !IsObject( value ); };\n\tfunction IsNumber( value ) { return !isNaN( value ) && value+0 === value; };\n\tvar IsFunction = ( function () {\n\t\tvar func_proto = Function.prototype;\n\t\treturn function IsFunction( target ) { return typeof target === 'function' && target != func_proto; };\n\t} ) ();\n\tfunction IsWindow( target ) { return target != null && (target === target.window); };\n\tfunction IsArrayLike( obj ) {\n\t\tif( !IsObject( obj ) || IsFunction( obj ) || IsWindow( obj ) )\n\t\t\treturn false;\n\t\tvar length = !!obj && ('length' in obj) && obj.length;\n\t\treturn IsArray( obj ) || length === 0 || IsNumber( length ) && length > 0 && ( length - 1 ) in obj;\n\t};\n\tfunction Slice( target, begin, end ) {\n\t\tvar i, result = [], size, len = target.length;\n\t\tbegin = ((begin = begin || 0) >= 0) ? begin : Math.max(0, len + begin);\n\t\tif((end = isNaN(end) ? len : Math.min(end, len)) < 0) end = len + end;\n\t\tif((size = end - begin) > 0) {\n\t\t\tresult = new Array(size);\n\t\t\tfor (i = 0; i < size; i++) result[i] = target[begin + i];\n\t\t}\n\t\treturn result;\n\t};\n\tfunction CanBeKey( value ) { return IsScalar( value ) || ( 'toString' in value ); };\n\n\t/**\n\t * For class inheritance.\n\t * @param {Function} child\tChild class.\n\t * @param {Function} parent\tParent class.\n\t * @return {Prototype}\t\tReturns created prototype of a child class.\n\t */\n\tfunction Inherit( child, parent ) {\n\t\tvar result = child.prototype = Object.create( parent && parent.prototype || null );\n\t\treturn ( result.constructor = child, result );\n\t};\n\n\t/**\n \t * Random string generation function.\n \t * @param {UINT}\tlen\tLength for the desired string.\n \t * @return {String}\n \t */\n\tfunction RandomString( len ) {\n\t\tlen = len || 8;\n\t\tvar id = '';\n\t\twhile( (id += Math.random().toString(16).slice(2), id.length < len) );\n\t\treturn id.slice(0, len);\n\t};\n\n\t/**\n\t * Returns unique ID for each object.\n\t * @param {Object}\ttarget\t\tTarget Object to get ID for.\n\t * @param {Boolean}\tdont_make\tIf target is an object and has no generated unique ID, \n\t *                              dont try to create a one.\n\t * @return {String}\n\t */\n\tfunction ItemID( target, dont_make ) {\n\n\t\t//\tIf target is a primitive, just typecast to string.\n\t\tif( !IsObject( target ) )\n\t\t\treturn target + \"\";\n\n\t\t//\tOtherwise generate random ID for this object and attach it as a constant.\n\t\tvar key = target.objectUniqueID;\n\t\tif( !key && !dont_make ) \n\t\t\tObject.defineProperty( target, 'objectUniqueID', { value: key = RandomString() } )\n\t\treturn key;\n\t};\n\n\t/**\n\t * Function to remove element with speicified index from array.\n\t * @param {Array}\tcontainer\tTarget array.\n\t * @param {UINT}\tindex\t\tWanted item index.\n\t * @return {Mixed} \t\t\t\tItem which has been removed from array.\n\t */\n\tfunction RemoveFrom ( container, index ) {\n\t\tvar result = container[ index ];\n\t\tcontainer.splice( index, 1 );\n\t\treturn result;\n\t};\n\n\t/**\n\t * Inserts an items to a specified position to array.\n\t * @param {ArrayLike}\tcontainer\tTarget array or array like object.\n\t * @param {List}\t\telements\tItem list or a single item.\n\t * @param {UINT}\t\tposition\tPosition where to add elements(appends if omitted).\n\t * @return {ArrayLike} \t\t\t\tGiven container.\n\t */\n\tfunction InsertAt ( container, elements, position ) {\n\t\tif( !IsArrayLike( elements ) ) \n\t\t\telements = [ elements ];\n\t\tif( position === undefined ) {\n\t\t\tArrayProto.push.apply( container, elements );\n\t\t} else {\n\t\t\tvar args = [ position, 0 ];\n\t\t\tArrayProto.push.apply( args, elements );\n\t\t\tArrayProto.splice.apply( container, args );\n\t\t}\n\t\treturn container;\n\t};\n\tvar FindAndRemove, FindAndRemoveOne;\n\t( function () {\n\t\tfunction Action ( container, list, is_unique ) {\n\t\t\tvar i = 1, result;\n\t\t\tfor( ; i < list.length; i++ ) {\n\t\t\t\tvar value = list[ i ], pos = 0;\n\t\t\t\twhile( ( pos = container.indexOf( value, pos ) ) != -1 ) {\n\t\t\t\t\tRemoveFrom( container, pos );\n\n\t\t\t\t\tif( is_unique ) \n\t\t\t\t\t\treturn pos;\n\t\t\t\t\telse if( !result )\n\t\t\t\t\t\tresult = [];\n\n\t\t\t\t\tresult.push( pos );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\t\t/**\n\t\t * Finds and removes needed items from array.\n\t\t * @param {Array}\t\tcontainer\tTarget array \n\t\t * @param {...Mixed}\titems\t\tItems to remove from target array.\n\t\t * @return {Mixed} \t\t\t\t\tItem which removed from array.\n\t\t */\n\t\tFindAndRemove = function ( container ) { return Action( container, arguments, false ); };\n\n\t\t/**\n\t\t * Alias for find and remove, \n\t\t * but considers that items are unique in the element, \n\t\t * and after deleting a particular item from array, stops searching for it anymore.\n\t\t * @param {Array}\t\tcontainer\tTarget array \n\t\t * @param {...Mixed}\titems\t\tItems to remove from target array.\n\t\t * @return {Mixed} \t\t\t\t\tItem which removed from array.\n\t\t */\n\t\tFindAndRemoveOne = function ( container ) { return Action( container, arguments, true ); };\n\t} ) ();\n\n\t/**\n\t * Iterable list class is for making Map and Set classes iterable.\n\t */\n\tfunction IterableList() {\n\t\tthis.values = [];\n\n\t\tthis.primitiveKeys = [];\n\t\tthis.keyToValue = {};\n\t}\n\t( function ( self, PROTOTYPE ) {\n\t\t/**\n\t\t * Object item list.\n\t\t * @type {Array}\n\t\t */\n\t\tPROTOTYPE.values = null;\n\n\t\tPROTOTYPE.primitiveKeys = null;\n\t\tPROTOTYPE.keyToValue = null;\n\n\t\t/**\n\t\t * Count of the items.\n\t\t * @type {UINT}\n\t\t */\n\t\tPROTOTYPE.length = 0;\n\n\t\t/**\n\t\t * Current element index pointer.\n\t\t * @type {Number}\n\t\t */\n\t\tPROTOTYPE.index = -1;\n\n\t\t/**\n\t\t * Current item's key.\n\t\t * @type {Mixed}\n\t\t */\n\t\tPROTOTYPE.key = null;\n\n\t\t/**\n\t\t * Current item's value.\n\t\t * @type {Mixed}\n\t\t */\n\t\tPROTOTYPE.value = null;\n\t\tfunction UpdateCurrent( get_value ) {\n\t\t\tthis.key = this.primitiveKeys[ this.index ] || null;\n\t\t\tthis.value = this.key && this.keyToValue[ this.key ];\n\t\t\treturn get_value ? this.value : !!this.key;\n\t\t}\n\n\t\t/**\n\t\t * Use this function to start iteration.\n\t\t */\n\t\tPROTOTYPE.start = function () {\n\t\t\tthis.index = -1;\n\t\t\tUpdateCurrent.call( this );\n\t\t};\n\n\t\t/**\n\t\t * Use this function to start reverse iteration.\n\t\t */\n\t\tPROTOTYPE.end = function () {\n\t\t\tthis.index = this.length;\n\t\t\tUpdateCurrent.call( this );\n\t\t};\n\n\t\t/**\n\t\t * Moves current item's pointer to the first element or gets the value of the first item.\n\t\t * @param  {Bool} get_value\tWether to get value of the item with desired index, or move pointer to that position.\n\t\t * @return {Mixed}\t\t\tIf get_value is true, returns value of desired item, otherwise returns true if position is valid.\n\t\t */\n\t\tPROTOTYPE.first = function ( get_value ) { this.index = 0; return UpdateCurrent.call( this, get_value ); };\n\n\t\t/**\n\t\t * Increments current item's pointer or gets the value of the next element(relative to current pointer position).\n\t\t * @param  {Bool} get_value\tWether to get value of the item with desired index, or move pointer to that position.\n\t\t * @return {Mixed}\t\t\tIf get_value is true, returns value of desired item, otherwise returns true if position is valid.\n\t\t */\n\t\tPROTOTYPE.next = function ( get_value ) { this.index++; return UpdateCurrent.call( this, get_value ); };\n\n\t\t/**\n\t\t * Decrements current item's pointer or gets the value of the next element(relative to current pointer position).\n\t\t * @param  {Bool} get_value\tWether to get value of the item with desired index, or move pointer to that position.\n\t\t * @return {Mixed}\t\t\tIf get_value is true, returns value of desired item, otherwise returns true if position is valid.\n\t\t */\n\t\tPROTOTYPE.prev = function ( get_value ) { this.index--; return UpdateCurrent.call( this, get_value ); };\t\t\n\n\t\t/**\n\t\t * Moves current item's pointer to the first element or gets the value of the last item.\n\t\t * @param  {Bool} get_value\tWether to get value of the item with desired index, or move pointer to that position.\n\t\t * @return {Mixed}\t\t\tIf get_value is true, returns value of desired item, otherwise returns true if position is valid.\n\t\t */\n\t\tPROTOTYPE.last = function ( get_value ) { this.index = this.length - 1; return UpdateCurrent.call( this, get_value ); };\n\n\t\t/**\n\t\t * These methods are aliases for functions defined above with get_value argument true.\n\t\t */\n\t\tPROTOTYPE.getFirst = function () { return this.first( true ); };\n\t\tPROTOTYPE.getNext = function () { return this.next( true ); };\n\t\tPROTOTYPE.getPrev = function () { return this.prev( true ); };\n\t\tPROTOTYPE.getLast = function () { return this.last( true ); };\n\n\t\t/**\n\t\t * Clear all items from the given Map or Set.\n\t\t * @return {this}\n\t\t */\n\t\tPROTOTYPE.clear = function () {\n\t\t\tthis.values = [];\n\t\t\tthis.primitiveKeys = [];\n\t\t\tthis.keyToValue = {};\n\t\t\tthis.length = 0;\n\t\t\tthis.index = -1;\n\t\t\tthis.key = null;\n\t\t\tthis.value = null;\n\t\t\treturn this;\n\t\t}\n\n\t\tfunction SetValue( key, value, ignore_if_had, index ) {\n\t\t\tvar had = HasOwn( this.keyToValue, key ), \n\t\t\t\tchanged = !had || !ignore_if_had;\n\t\t\tif( !had ) {\n\t\t\t\tInsertAt( this.values, value, index );\n\t\t\t\tInsertAt( this.primitiveKeys, key, index );\n\t\t\t\tthis.length++;\n\t\t\t}\n\t\t\tif( changed ) {\n\t\t\t\tif( had )\n\t\t\t\t\tthis.values[ this.primitiveKeys.indexOf( key ) ] = value;\n\t\t\t\tthis.keyToValue[ key ] = value;\n\t\t\t}\n\t\t\treturn changed;\n\t\t};\n\t\tfunction GetValue( key ) { return this.keyToValue[ key ]; };\n\t\tfunction HasValue( key ) { return HasOwn( this.keyToValue, key ); };\n\t\tfunction DeleteValue( key ) {\n\t\t\tvar index = -1, has = HasOwn( this.keyToValue, key );\n\t\t\tif( has ) {\n\t\t\t\tdelete this.keyToValue[ key ];\n\t\t\t\tRemoveFrom( this.values, index = FindAndRemoveOne( this.primitiveKeys, key ) );\n\t\t\t\tthis.length--;\n\t\t\t}\n\t\t\treturn index;\n\t\t}\n\n\t\tself.set = function ( target, key, value, ignore_if_had, index ) {\n\t\t\treturn SetValue.call( target, key, value, ignore_if_had, index );\n\t\t};\n\t\tself.get = function ( target, key ) {\n\t\t\treturn GetValue.call( target, key );\n\t\t}\n\t\tself.has = function ( target, key ) {\n\t\t\treturn HasValue.call( target, key );\n\t\t};\n\t\tself.delete = function ( target, key ) {\n\t\t\treturn DeleteValue.call( target, key );\n\t\t};\n\t} ) ( IterableList, IterableList.prototype );\n\n\t/**\n\t * Map constructor function.\n\t */\n\tfunction FastMap() {\n\t\tthis.keys = [];\n\t\tthis.IDToKey = {};\n\t\tIterableList.call( this );\n\t};\n\tmain.map = FastMap;\n\t( function ( PROTOTYPE, ParentProto ) {\n\n\t\t/**\n\t\t * Keys container.\n\t\t * @type {Array}\n\t\t */\n\t\tPROTOTYPE.keys = null;\n\t\tPROTOTYPE.IDToKey = null;\n\t\tfunction SetValue( key, value, ignore_if_had, position ) {\n\t\t\tvar real_key = ItemID( key ), \n\t\t\t\tsaved = !!real_key && IterableList.set( this, real_key, value, ignore_if_had, position );\n\t\t\tif( saved ) {\n\t\t\t\tInsertAt( this.keys, key, position );\n\t\t\t\tthis.IDToKey[ real_key ] = key;\n\t\t\t}\n\t\t\treturn saved;\n\t\t};\n\n\t\t/**\n\t\t * Set a key value pair for this Map.\n\t\t * @param {Mixed}\tkey\t\t\tCan be any type, including objects.\n\t\t * @param {Mixed}\titem\t\tItem that need's to be seted.\n\t\t * @param {UINT}\tposition\tPosition of the new item(appends if ommited)\n\t\t * @return {this}\n\t\t */\n\t\tPROTOTYPE.set = function ( key, item, position ) {\n\t\t\tSetValue.call( this, key, item, false, position );\n\t\t\treturn this;\n\t\t};\n\n\t\t/**\n\t\t * Add a key value pair for this Map.\n\t\t * Same as set, but sets an item only if given key is not used.\n\t\t * @param {Mixed}\tkey\t\t\tCan be any type, including objects.\n\t\t * @param {Mixed}\titem\t\tItem that need's to be seted.\n\t\t * @param {UINT}\tposition\tPosition of the new item(appends if ommited)\n\t\t * @return {Bool}\t\t\t\tReturns true if item has been added.\n\t\t */\n\t\tPROTOTYPE.add = function ( key, item, position ) {\n\t\t\treturn SetValue.call( this, key, item, true, position );\n\t\t};\n\n\t\tfunction IncChange ( key, val, ret_old ) {\n\t\t\tvar value, result;\n\t\t\tif( !this.has( key ) ) {\n\t\t\t\tvalue = 0;\n\t\t\t} else if( !IsNumber( value = this.get( key ) ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tresult = value;\n\t\t\tif( !SetValue.call( this, key, value += val ) ) {\n\t\t\t\tresult = false;\n\t\t\t} else if( !ret_old )\n\t\t\t\tresult = value;\n\t\t\treturn result;\n\t\t};\n\n\t\t/**\n\t\t * Increments number value of this key and works like i++.\n\t\t * If this key is not used yet, sets the value to 1.\n\t\t * @param  {Mixed} \tkey\n\t\t * @return {Number}\t\tFalse if key was already used and that item was not a number.\n\t\t */\n\t\tPROTOTYPE['++'] = function ( key ) { return IncChange.call( this, key, 1, true ); };\n\n\t\t/**\n\t\t * Decrements number value of this key and works like --i.\n\t\t * If this key is not used yet, sets the value to -1.\n\t\t * @param  {Mixed} \tkey\n\t\t * @return {Number}\t\tFalse if key was already used and that item was not a number.\n\t\t */\n\t\tPROTOTYPE['--'] = function ( key ) { return IncChange.call( this, key, -1 ); };\n\n\t\tfunction ArrayChange ( key, handler, args, rewrite ) {\n\t\t\tvar has = this.has( key ), result = false, value;\n\t\t\tif( has ? IsArrayLike( value = this.get( key ) ) : args ) {\n\t\t\t\tif( !has ) \n\t\t\t\t\tvalue = [];\n\n\t\t\t\tresult = handler.apply( value, args || [] );\n\t\t\t\tif( rewrite ) \n\t\t\t\t\tvalue = result;\n\n\t\t\t\tif( (!has || rewrite) && !SetValue.call( this, key, value ) )\n\t\t\t\t\tresult = false;\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\n\t\t/**\n\t\t * Pushes item into the array item of this key.\n\t\t * Creates blank array if key is not used yet.\n\t\t * @param  {Mixed}\tkey\n \t\t * @return {UINT}     \tReturns result of push operation.\n\t\t */\n\t\tPROTOTYPE.push = function ( key ) { return ArrayChange.call( this, key, ArrayProto.push, Slice( arguments, 1 ) ); };\n\n\t\t/**\n\t\t * Unshifts item into the array item of this key.\n\t\t * Creates blank array if key is not used yet.\n\t\t * @param  {Mixed}\tkey\n \t\t * @return {UINT}     \tReturns result of unshift operation.\n\t\t */\n\t\tPROTOTYPE.unshift = function ( key ) { return ArrayChange.call( this, key, ArrayProto.unshift, Slice( arguments, 1 ) ); };\n\n\t\t/**\n\t\t * Concats given arrays to this Map|Set.\n\t\t * Creates blank array if key is not used yet.\n\t\t * @param  {Mixed}\tkey\n \t\t * @return {Mixed}\t\tReturns desired array, or false if the item was not an array.\n\t\t */\n\t\tPROTOTYPE.concat = function ( key ) { return ArrayChange.call( this, key, ArrayProto.concat, Slice( arguments, 1 ), true ); };\n\n\t\t/**\n\t\t * Splices array item of this key.\n\t\t * Creates blank array if key is not used yet.\n\t\t * @param  {Mixed}\tkey\n \t\t * @return {Mixed}\t\tReturns desired array, or false if the item was not an array.\n\t\t */\n\t\tPROTOTYPE.splice = function ( key ) { return ArrayChange.call( this, key, ArrayProto.splice, Slice( arguments, 1 ), true ); };\n\n\t\t/**\n\t\t * Pops item from array item of this key.\n\t\t * Ignroes if key is not set.\n\t\t * @param  {Mixed}\tkey\n \t\t * @return {Mixed}\t\tReturns popped element or null.\n\t\t */\n\t\tPROTOTYPE.pop = function ( key ) { return ArrayChange.call( this, key, ArrayProto.pop ); };\n\n\t\t/**\n\t\t * Shifts item from array item of this key.\n\t\t * Ignroes if key is not set.\n\t\t * @param  {Mixed}\tkey\n \t\t * @return {Mixed}\t\tReturns popped element or null.\n\t\t */\n\t\tPROTOTYPE.shift = function ( key ) { return ArrayChange.call( this, key, ArrayProto.shift ); };\n\n\t\tfunction SetObjectProperty ( key, name, value, add ) {\n\t\t\tvar values, has = this.has( key ), added;\n\t\t\tif( has ? !IsObject( values = this.get( key ) ) : !SetValue.call( this, key, values = {} ) )\n\t\t\t\treturn false;\n\n\t\t\tadded = !HasOwn( values, name ) || !add;\n\t\t\tif( added )\n\t\t\t\tvalues[ name ] = value;\n\t\t\treturn added;\n\t\t};\n\n\t\t/**\n\t\t * Sets property to a object item of this key.\n\t\t * Creates blank object if key is not used yet.\n\t\t * @param {Mixed}\tkey\n\t\t * @param {Scalar}\tname  \tName of the new entry in that object.\n\t\t * @param {Mixed}\tvalue \tValue of the new entry in that object.\n\t\t * @return {Object}\t\t\tObject item of this key or null\n\t\t */\n\t\tPROTOTYPE.setProp = function ( key, name, value ) { return SetObjectProperty.call( this, key, name, value, false ); };\n\n\t\t/**\n\t\t * Same as setProperty, but does nothing and returns false if key is already defined, \n\t\t * or true if the key was new.\n\t\t * @param {Mixed}\tkey\n\t\t * @param {Scalar}\tname  \tName of the new entry in that object.\n\t\t * @param {Mixed}\tvalue \tValue of the new entry in that object.\n\t\t * @return {Object}\t\t\tObject item of this key or null\n\t\t */\n\t\tPROTOTYPE.addProp = function ( key, name, value ) { return SetObjectProperty.call( this, key, name, value, true ); };\n\n\t\t/**\n\t\t * Get property of an object item of the given key.\n\t\t * Returns null if key is already defined and is a scalar value.\n\t\t * @param {Mixed}\tkey\n\t\t * @param {Scalar}\tname  Name of the property in that object.\n\t\t * @return {Mixed}\n\t\t */\n\t\tPROTOTYPE.getProp = function ( key, name ) {\n\t\t\tvar target;\n\t\t\treturn this.has( key ) && IsObject( target = this.get( key ) ) && target[ name ];\n\t\t};\n\n\t\t/**\n\t\t * Checks if item of given key is an object, and it has own given property.\n\t\t * @param  {Mixed}\t\tkey  \n\t\t * @param  {Mixed}\t\tproperty\tProperty name to delete.\n\t\t * @return {Boolean}\n\t\t */\n\t\tPROTOTYPE.hasProp = function ( key, name ) {\n\t\t\tvar target;\n\t\t\treturn CanBeKey( name ) && this.has( key ) && IsObject( target = this.get( key ) ) && HasOwn( target, name );\n\t\t};\n\n\t\t/**\n\t\t * Checks if item of given key is an object, and deletes property from that object.\n\t\t * @param  {Mixed}\t\tkey\t\t\n\t\t * @param  {Mixed}\t\tproperty\tProperty name to delete.\n\t\t * @return {Boolean}\t\t\t\tReturnes bool indicating if given name has been deleted from target object.\n\t\t */\n\t\tPROTOTYPE.deleteProp = function ( key, property ) {\n\t\t\tvar target, \n\t\t\t\tdeleted = this.has( key ) && IsObject( target = this.get( key ) ) && HasOwn( target, property );\n\t\t\tif( deleted )\n\t\t\t\tdelete target[ property ];\n\t\t\treturn deleted;\n\t\t};\n\n\t\t/**\n\t\t * Get item of given key.\n\t\t * @param  {Mixed}\tkey\n\t\t * @return {Mixed}\n\t\t */\n\t\tPROTOTYPE.get = function ( key ) {\n\t\t\tvar real_key = ItemID( key, true );\n\t\t\treturn ( real_key && IterableList.get( this, real_key ) ) || undefined;\n\t\t};\n\n\t\t/**\n\t\t * Checks if given key exists in this object.\n\t\t * @param  {Mixed}\t\tkey\n\t\t * @return {Boolean}\n\t\t */\n\t\tPROTOTYPE.has = function ( key ) {\n\t\t\tvar real_key = ItemID( key, true );\n\t\t\treturn !!real_key && IterableList.has( this, real_key );\n\t\t};\n\n\t\t/**\n\t\t * Delete item for given key.\n\t\t * @param  {Mixed} \t\tkey\n\t\t * @return {Boolean}\ttrue if key existed\n\t\t */\n\t\tPROTOTYPE.delete = function ( key ) {\n\t\t\tvar real_key = ItemID( key ), \n\t\t\t\thad = !!real_key && HasOwn( this.IDToKey, real_key );\n\t\t\tif( had ) {\n\t\t\t\tdelete this.IDToKey[ real_key ];\n\t\t\t\tRemoveFrom( this.keys, IterableList.delete( this, real_key ) );\n\t\t\t}\n\t\t\treturn had;\n\t\t};\n\t\tfunction PointerMoveAction( name, args ) {\n\t\t\tvar result = ParentProto[ name ].apply( this, args );\n\t\t\tthis.key = this.IDToKey[ this.key ];\n\t\t\treturn result;\n\t\t};\n\n\t\t//\tSome fixes for pointer move operations of FastMap.\n\t\tPROTOTYPE.first = function () { return PointerMoveAction.call( this, 'first', arguments ); };\n\t\tPROTOTYPE.next = function () { return PointerMoveAction.call( this, 'next', arguments ); };\n\t\tPROTOTYPE.prev = function () { return PointerMoveAction.call( this, 'prev', arguments ); };\n\t\tPROTOTYPE.last = function () { return PointerMoveAction.call( this, 'last', arguments ); };\n\t\tif( symbols_supported ) {\n\t\t\tPROTOTYPE[Symbol.iterator] = function () {\n\t\t\t\tvar that = this;\n\t\t\t\tthis.start();\n\t\t\t\treturn {\n\t\t\t\t\tnext: function () {\n\t\t\t\t\t\tvar done = !that.next();\n\t\t\t\t\t\treturn { done: done, value: [that.key, that.value] };\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\tPROTOTYPE.clear = function () {\n\t\t\tParentProto.clear.call( this );\n\t\t\tthis.IDToKey = {};\n\t\t};\n\n\t\t/**\n\t\t * Used to clone this FastMap object.\n\t\t * @return {FastMap}\n\t\t */\n\t\tPROTOTYPE.clone = function () {\n\t\t\tvar cloned = new FastMap();\n\t\t\tthis.start();\n\t\t\twhile( this.next() ) \n\t\t\t\tcloned.add( this.key, this.value );\n\t\t\treturn cloned;\n\t\t};\n\t} ) ( Inherit( FastMap, IterableList ), IterableList.prototype );\n\n\t/**\n\t * Set constructor.\n\t * @param {ArrayLike}\tlist\tInitial list of items.\n\t */\n\tfunction FastSet( list ) {\n\t\tIterableList.call( this );\n\t\tif( list ) {\n\t\t\tif( !IsArrayLike( list ) )\n\t\t\t\tlist = [ list ];\n\t\t\tthis.addMulti( list );\n\t\t}\n\t};\n\tmain.set = FastSet;\n\t( function ( PROTOTYPE ) {\n\n\t\t/**\n\t\t * Adds item.\n\t\t * @param {Mixed}\titem \tValue to add.\n\t\t * @param {UINT}\ti\t\tPosition of a new item( item will be appended if ommited ).\n\t\t * @return {Boolean} \t\tTrue if item is new.\n\t\t */\n\t\tPROTOTYPE.add = function ( item, position ) {\n\t\t\tvar real_key = ItemID( item );\n\t\t\treturn !!real_key && IterableList.set( this, real_key, item, true, position );\n\t\t};\n\n\t\t/**\n\t\t * Adds multiple items.\n\t\t * @param {ArrayLike}\tlist \tValue to add.\n\t\t * @param {UINT}\t\ti\t\tPosition of a new item. If not given, items will be appended.\n\t\t * @return {UINT} \t\t\t\tAdded items count.\n\t\t */\n\t\tPROTOTYPE.addMulti = function ( list, position ) {\n\t\t\tvar addeds = 0, i = 0;\n\t\t\tfor( ; i < list.length; i++ ) \n\t\t\t\tif( this.add( list[i], position ) ) \n\t\t\t\t\taddeds++;\n\t\t\treturn addeds;\n\t\t};\n\n\t\t/**\n\t\t * Checks if item exists.\n\t\t * @param  {Mixed}  item\tItem to check.\n\t\t * @return {Boolean}\n\t\t */\n\t\tPROTOTYPE.has = function ( item ) {\n\t\t\tvar real_id = ItemID( item, true );\n\t\t\treturn !!real_id && IterableList.has( this, real_id );\n\t\t};\n\n\t\t/**\n\t\t * Deletes given item.\n\t\t * @param  {Mixed}\t\titem\tItem to delete from this set.\n\t\t * @return {Boolean}\t\t\tTrue if item existed and has been deleted.\n\t\t */\n\t\tPROTOTYPE.delete = function ( item ) {\n\t\t\tvar real_id = ItemID( item, true );\n\t\t\treturn IterableList.delete( this, real_id ) != -1;\n\t\t};\n\t\tif( symbols_supported ) {\n\t\t\tPROTOTYPE[Symbol.iterator] = function () {\n\t\t\t\tvar that = this;\n\t\t\t\tthis.start();\n\t\t\t\treturn {\n\t\t\t\t\tnext: function () {\n\t\t\t\t\t\tvar done = !that.next();\n\t\t\t\t\t\treturn { done: done, value: that.value };\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\t/**\n\t\t * Used to clone this FastSet object.\n\t\t * @return {FastSet}\n\t\t */\n\t\tPROTOTYPE.clone = function () {\n\t\t\tvar cloned = new FastSet();\n\t\t\tthis.start();\n\t\t\twhile( this.next() ) \n\t\t\t\tcloned.add( this.value );\n\t\t\treturn cloned;\n\t\t};\n\t} ) ( Inherit( FastSet, IterableList ) );\n\n\treturn main;\n} );\n\n//# sourceURL=webpack:///./node_modules/es6-set-and-map/src/main.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ })

/******/ });